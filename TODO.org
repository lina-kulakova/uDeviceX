* Analytic wall

- r, v, f    ::  current position, velocity and force
- rp, vp, fp :: previous ...
- cheap test
- r, rp -> t

*
* Notation

XS, YS, ZS   : subdomain size
XWM, YWM, ZWM: wall margins
 XE,  YE,  ZE : extended subdomain size XS + 2*XWM
XTE, YTE, ZTE : "texture size", sdf grid from a file is mapped to a new grid XT, YT, ZT

* Rest

bipsbatch: bi-party batch

nv: number of vertices
nc: number of cells
r_nv * r_nc == r_n

Cont::rbc_dump, Cont::rbc_dump0 -> goes to io

rbc_remove -> goes to wall
wall::init freezes `s' inside the wall

cnt -> cont

r[3]: [rx, ry, rz]
v[3]: [vx, vy, vz]

Struct RV {
  float r[3], v[3]
}  rv

Struct Force {
  float f[3]
}

fx = s_ff[idx].f[0]; fx = s_f[idx].f[1]; fx = s_f[idx].f[2]
RV s_rv[100]

s_*: array; r_*: array; c_*: array

s_rv, s_ff: solvent
r_rv, r_ff: rbc

dstr_s
   input: s_rv
  output: s_rv

dpd_ss
    input: s_rv
   output: s_ff

clfor(s_ff)
    input: s_ff
    ouput: s_ff

clvel_s
    input: s_rv
   output: s_rv

cnt_rr
     input: r_pp
    output: r_ff

fsi::pre()
fsi::fsi(s_rv, r_rv,    s_ff, r_ff)
    input: s_rv, r_rv
   output: s_ff, r_ff
fsi::post()

bounce_sr
    input: s_rv, r_rv
   output: s_rv, r_ff

bounce_sw
    input: s_rv, w_rv
   output: s_rv

memb_rr:
    input: r_rv
    input: r_ff
